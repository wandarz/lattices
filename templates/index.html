<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buffon's Needle Experiment</title>
    <style>
        :root {
            --bg: #0f1419;
            --surface: #1a2332;
            --border: #2d3a4d;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --text: #e6edf3;
            --text-muted: #8b949e;
            --crossing: #22c55e;
            --non-crossing: #64748b;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 24px;
            min-height: 100vh;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0 0 8px 0;
            letter-spacing: -0.02em;
        }

        .subtitle {
            color: var(--text-muted);
            font-size: 0.875rem;
            margin-bottom: 24px;
        }

        .layout {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        .controls {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            width: 280px;
            height: fit-content;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-of-type {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 0.95rem;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent);
        }

        button {
            width: 100%;
            padding: 14px 20px;
            background: var(--accent);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s;
        }

        button:hover {
            background: var(--accent-hover);
        }

        button:active {
            transform: scale(0.98);
        }

        .canvas-container {
            flex: 1;
            min-width: 400px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            overflow: hidden;
        }

        .canvas-with-stats {
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        .canvas-wrapper {
            flex-shrink: 0;
            background: var(--bg);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas {
            display: block;
            background: var(--bg);
        }

        .stats {
            flex-shrink: 0;
            padding: 16px;
            background: var(--bg);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .stats-value {
            font-weight: 600;
            color: var(--accent);
        }

        .stats-value.crossing {
            color: var(--crossing);
        }
    </style>
</head>
<body>
    <h1>Buffon's Needle Experiment</h1>
    <p class="subtitle">Throw needles on a grid of vertical lines and observe the crossings</p>

    <div class="layout">
        <div class="controls">
            <div class="control-group">
                <label for="ratio">Needle/line ratio (d/l)</label>
                <input type="number" id="ratio" value="0.6" min="0.1" max="2" step="0.1">
            </div>
            <div class="control-group">
                <label for="num-lines">Number of vertical lines</label>
                <input type="number" id="num-lines" value="16" min="2" max="50" step="1">
            </div>
            <div class="control-group">
                <label for="needle-count">Number of needles (N)</label>
                <input type="number" id="needle-count" value="100" min="1" max="10000" step="10">
            </div>
            <div class="control-group">
                <button id="throw-btn">Throw needles</button>
            </div>
        </div>

        <div class="canvas-container">
            <div class="canvas-with-stats">
                <div class="canvas-wrapper">
                    <canvas id="canvas" width="800" height="600"></canvas>
                </div>
                <div class="stats" id="stats" style="display: none;">
                <div class="stats-row">
                    <span>Needles on lines (crossing):</span>
                    <span class="stats-value crossing" id="crossing-count">0</span>
                </div>
                <div class="stats-row">
                    <span>Total needles:</span>
                    <span class="stats-value" id="total-count">0</span>
                </div>
                <div class="stats-row">
                    <span>Probability p:</span>
                    <span class="stats-value" id="probability">—</span>
                </div>
                <div class="stats-row" id="pi-row" style="display: none;">
                    <span>π approximation:</span>
                    <span class="stats-value" id="pi-estimate">—</span>
                </div>
            </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const ratioInput = document.getElementById('ratio');
        const numLinesInput = document.getElementById('num-lines');
        const needleCountInput = document.getElementById('needle-count');
        const throwBtn = document.getElementById('throw-btn');
        const statsDiv = document.getElementById('stats');
        const crossingCountEl = document.getElementById('crossing-count');
        const totalCountEl = document.getElementById('total-count');
        const probabilityEl = document.getElementById('probability');
        const piEstimateEl = document.getElementById('pi-estimate');
        const piRow = document.getElementById('pi-row');

        const LOGICAL_WIDTH = 800;
        const LOGICAL_HEIGHT = 600;

        let currentNeedles = [];
        let currentL = 0;
        let currentD = 0;

        function getL() {
            const numLines = Math.max(2, parseInt(numLinesInput.value, 10) || 16);
            return LOGICAL_WIDTH / (numLines - 1);
        }

        function getD() {
            const ratio = parseFloat(ratioInput.value) || 0.6;
            return ratio * getL();
        }

        function redraw() {
            const l = getL();
            const d = getD();
            drawGrid(l);
            if (currentNeedles.length > 0) {
                drawNeedles(currentNeedles, l, d);
            }
        }

        function drawGrid(l) {
            ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);

            ctx.strokeStyle = '#2d3a4d';
            ctx.lineWidth = 1;
            ctx.setLineDash([]);

            const numLines = Math.max(2, parseInt(numLinesInput.value, 10) || 16);
            for (let k = 0; k < numLines; k++) {
                const x = k * l;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, LOGICAL_HEIGHT);
                ctx.stroke();
            }
        }

        function checkCrossing(x, angle, l, d) {
            const halfSpan = (d / 2) * Math.abs(Math.cos(angle));
            if (halfSpan <= 0 || l <= 0) return false;
            const kMin = Math.floor((x - halfSpan) / l);
            const kMax = Math.ceil((x + halfSpan) / l);
            for (let k = kMin; k <= kMax; k++) {
                if (Math.abs(x - k * l) <= halfSpan) return true;
            }
            return false;
        }

        function drawNeedle(needle, l, d) {
            const crosses = needle.crosses !== undefined ? needle.crosses : checkCrossing(needle.x, needle.angle, l, d);
            const halfLen = d / 2;
            const x1 = needle.x - halfLen * Math.cos(needle.angle);
            const y1 = needle.y - halfLen * Math.sin(needle.angle);
            const x2 = needle.x + halfLen * Math.cos(needle.angle);
            const y2 = needle.y + halfLen * Math.sin(needle.angle);

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = crosses ? '#22c55e' : '#64748b';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawNeedles(needles, l, d) {
            needles.forEach(needle => drawNeedle(needle, l, d));
        }

        function updateStats(crossingCount, totalCount, l, d, ratio) {
            crossingCountEl.textContent = crossingCount;
            totalCountEl.textContent = totalCount;

            const p = totalCount > 0 ? crossingCount / totalCount : 0;
            probabilityEl.textContent = totalCount > 0 ? p.toFixed(4) : '—';

            if (ratio < 1 && totalCount > 0 && p > 0) {
                const piEst = (2 * d) / (p * l);
                piRow.style.display = '';
                piEstimateEl.textContent = piEst.toFixed(6);
            } else {
                piRow.style.display = 'none';
            }
        }

        function resizeCanvas() {
            const container = canvas.parentElement.parentElement;
            const rect = container.getBoundingClientRect();
            const maxWidth = Math.min(900, rect.width - 32);
            const scale = maxWidth / LOGICAL_WIDTH;
            canvas.width = LOGICAL_WIDTH;
            canvas.height = LOGICAL_HEIGHT;
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (LOGICAL_HEIGHT * scale) + 'px';
            redraw();
        }

        throwBtn.addEventListener('click', async () => {
            const ratio = parseFloat(ratioInput.value) || 0.6;
            const numLines = Math.max(2, parseInt(numLinesInput.value, 10) || 16);
            const n = parseInt(needleCountInput.value, 10) || 100;
            const l = LOGICAL_WIDTH / (numLines - 1);
            const d = ratio * l;

            if (ratio <= 0) {
                alert('Ratio d/l must be positive.');
                return;
            }
            if (numLines < 2) {
                alert('Number of vertical lines must be at least 2.');
                return;
            }
            if (n < 1 || n > 10000) {
                alert('Number of needles must be between 1 and 10000.');
                return;
            }

            throwBtn.disabled = true;
            throwBtn.textContent = 'Throwing...';

            try {
                const response = await fetch('/api/throw', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        l,
                        d,
                        n,
                        canvas_width: LOGICAL_WIDTH,
                        canvas_height: LOGICAL_HEIGHT
                    })
                });

                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'Request failed');
                }

                const result = await response.json();
                currentNeedles = result.needles;
                currentL = l;
                currentD = d;

                drawGrid(l);
                statsDiv.style.display = 'block';

                for (let i = 0, crossings = 0; i < result.needles.length; i++) {
                    drawNeedle(result.needles[i], l, d);
                    crossings += result.needles[i].crosses ? 1 : 0;
                    updateStats(crossings, i + 1, l, d, ratio);
                    if (i < result.needles.length - 1) {
                        await new Promise(r => setTimeout(r, 1));
                    }
                }

                updateStats(result.crossing_count, result.total_count, l, d, ratio);
            } catch (err) {
                alert('Error: ' + err.message);
            } finally {
                throwBtn.disabled = false;
                throwBtn.textContent = 'Throw needles';
            }
        });

        function refreshStats() {
            if (currentNeedles.length === 0) return;
            const l = getL();
            const d = getD();
            const ratio = parseFloat(ratioInput.value) || 0.6;
            const crossingCount = currentNeedles.filter(n =>
                checkCrossing(n.x, n.angle, l, d)
            ).length;
            updateStats(crossingCount, currentNeedles.length, l, d, ratio);
        }

        ratioInput.addEventListener('change', () => {
            redraw();
            refreshStats();
        });
        numLinesInput.addEventListener('change', () => {
            redraw();
            refreshStats();
        });

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
